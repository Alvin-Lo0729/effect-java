覆蓋equals方法看起來似乎很簡單，但是有許多override方式會導致錯誤，並且後果非常嚴重。

==== 什麼時候不應該覆蓋equals

* **Each instance of the class is inherently unique**
+
對於代表例如像thread這種類別的instance，而不是代表value的instance，其object提供的equals方法就是適用的。

* **There is no need for the to provide a "logical equality" test**
+
例如java.util.regex.Pattern可以覆蓋equals方法，以檢查兩個Pattern instance是否代表相同的正規表示式，但是設計者並不認為使用者需要或者期望這樣的功能。在這種情況下，其object提供的equals方法就是適用的。

* **A superclass has already overridden equals, and the superclass behavior is appropriate for this class**
+
例如Set從AbstractSet繼承了已實作的equals方法，List從AbstractList繼承了已實作的equals方法，Map從AbstractMap繼承了已實作的equals方法

* ** The class is private or package-private , and you are certain that its equals method will never be invoked**
+
如果你確定equals方法永遠不會被調用，那麼可以override equals方法，確保他不會被意外調用

[source,java]
----

public class PrivateClass{
  private int x;
  private int y;

  @Override
  public boolean equals(Object o){
    throw new AssertionError(); // Method is never called
  }
}

----


