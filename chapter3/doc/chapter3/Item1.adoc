覆蓋equals方法看起來似乎很簡單，但是有許多override方式會導致錯誤，並且後果非常嚴重。

==== 什麼時候不應該覆蓋equals
如果滿足下列任一條件，則不應該覆蓋equals方法：

* **Each instance of the class is inherently unique**
+
對於代表例如像thread這種類別的instance，而不是代表value的instance，其object提供的equals方法就是適用的。

* **There is no need for the to provide a "logical equality" test**
+
例如java.util.regex.Pattern可以覆蓋equals方法，以檢查兩個Pattern instance是否代表相同的正規表示式，但是設計者並不認為使用者需要或者期望這樣的功能。在這種情況下，其object提供的equals方法就是適用的。

* **A superclass has already overridden equals, and the superclass behavior is appropriate for this class**
+
例如Set從AbstractSet繼承了已實作的equals方法，List從AbstractList繼承了已實作的equals方法，Map從AbstractMap繼承了已實作的equals方法

* ** The class is private or package-private , and you are certain that its equals method will never be invoked**
+
如果你確定equals方法永遠不會被調用，那麼可以override equals方法，確保他不會被意外調用

[source,java]
----

public class PrivateClass{
  private int x;
  private int y;

  @Override
  public boolean equals(Object o){
    throw new AssertionError(); // Method is never called
  }
}

----


==== 那麼什麼時候該override equals function?

通常屬於 "value" 類別的instance，例如String、Integer、Date，這些instance代表的是一個value，這種情況下，equals方法應該被覆蓋，以便比較這些instance的value是否相等。

但有一種"value"類別，不需要override equals，就是enum

在override equals 的時候，必須要遵守他的general contract，有以下幾點：

* **Reflexive(自反性)** : 對於任何非null的引用值x, x.equals(x)必須回傳true
* **Symmetric(對稱性)** : 對於任何非null的引用值x, x.equals(x)必須回傳true

